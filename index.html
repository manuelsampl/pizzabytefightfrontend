<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="utf-8" />
    <title>Pizza Royale ‚Äì 30s</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        html,
        body {
            margin: 0;
            background: #0b0f14;
            color: #fff;
            font-family: system-ui, Segoe UI, Arial
        }

        canvas {
            display: block;
            margin: 0 auto;
            width: 540px;
            /* Instagram Reel Aspect Ratio: 9:16, scaled f√ºr Desktop viewing */
            height: 960px;
            background: radial-gradient(ellipse at center, #101722 0%, #070a0f 70%);
            border: 2px solid #333;
        }

        #ui {
            position: absolute;
            inset: 0;
            pointer-events: none
        }

        .hud {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 50px;
            text-align: center
        }

        .timer {
            font-size: 40px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, .6)
        }

        .subtitle {
            font-size: 14px;
            opacity: .85
        }

        .board {
            position: absolute;
            right: 24px;
            top: 60px;
            background: rgba(0, 0, 0, .45);
            backdrop-filter: blur(4px);
            padding: 12px 14px;
            border-radius: 12px;
            max-width: 360px
        }

        .board h3 {
            margin: 0 0 8px 0;
            font-size: 18px;
            opacity: .8
        }

        .board ol {
            margin: 0;
            padding-left: 16px;
            font-size: 16px;
            line-height: 1.4;
            max-height: 280px;
            overflow: auto
        }

        .badge {
            display: inline-block;
            margin-left: 8px;
            font-size: 11px;
            opacity: .75
        }

        #main-menu button:hover {
            transform: translateY(-2px);
        }
    </style>
</head>

<body>
    <div id="main-menu"
        style="position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:20;display:flex;flex-direction:column;align-items:center;justify-content:center;">
        <h1 style="font-size:4em;color:#ff6b35;text-shadow:0 0 20px rgba(255,107,53,0.5);margin-bottom:40px;">üçï Pizza
            Royale</h1>
        <div style="display:flex;flex-direction:column;gap:20px;">
            <button id="startFightBtn"
                style="font-size:24px;padding:16px 32px;background:linear-gradient(45deg,#ff6b35,#ff8e53);color:white;border:none;border-radius:12px;cursor:pointer;box-shadow:0 4px 15px rgba(255,107,53,0.3);transition:transform 0.3s;">üéÆ
                Pizza Royale starten</button>
            <button id="importBtn"
                style="font-size:20px;padding:12px 24px;background:linear-gradient(45deg,#667eea,#764ba2);color:white;border:none;border-radius:12px;cursor:pointer;box-shadow:0 4px 15px rgba(102,126,234,0.3);transition:transform 0.3s;">üì∏
                Instagram Follower importieren</button>
        </div>
        <p style="margin-top:40px;color:#ccc;text-align:center;max-width:600px;line-height:1.6;">Deine Instagram
            Follower k√§mpfen als Avatare um die letzte Pizza! 20 Sekunden Battle Royale, automatisch als MP4 aufgenommen
            f√ºr deine Story.</p>
    </div>

    <canvas id="game" width="1080" height="1920"></canvas>
    <div id="ui">
        <div class="hud">
            <div class="">Countdown:</div>
            <div class="timer" id="t">20.0</div>
        </div>
        <div class="board" id="board">
            <h3>Live Ranking (Pizza Eaten)</h3>
            <ol id="rank"></ol>
        </div>
    </div>
    <script type="module">
        // ====== MENU HANDLING ======
        const mainMenu = document.getElementById('main-menu');
        const startBtn = document.getElementById('startFightBtn');
        const importBtn = document.getElementById('importBtn');

        // Import Button Handler
        importBtn.onclick = () => {
            window.location.href = 'import.html';
        };

        // Start Game Button Handler  
        startBtn.onclick = async () => {
            mainMenu.style.display = 'none';

            try {
                const res = await fetch('http://localhost:4000/api/matches', { method: 'POST' });
                if (res.ok) {
                    await startGame();
                } else {
                    alert('Fehler beim Starten des Kampfes!');
                    mainMenu.style.display = 'flex';
                }
            } catch (error) {
                console.error('Error starting game:', error);
                await startGame(); // Start anyway with demo data
            }
        };

        // ====== GAME LOGIC ======
        async function startGame() {
            // ====== CONFIG ======
            const WIDTH = 1080, HEIGHT = 1920, DURATION = 30.0;
            const WINNER_DISPLAY_TIME = 5.0;
            const MAX_PLAYERS = 1000;
            const AVA_R = 26;
            const MAX_SPEED = 18;
            const EAT_RADIUS = 150;
            const PIZZA_CENTER = { x: WIDTH / 2, y: HEIGHT / 2 };

            // ====== ROSTER ======
            let roster;
            try {
                console.log('Fetching roster from API...');
                const res = await fetch('http://localhost:4000/api/roster');
                console.log('API response status:', res.status);
                if (res.ok) {
                    roster = await res.json();
                    console.log('Roster loaded from API:', roster.length, 'players');
                    console.log('First player:', roster[0]);
                } else {
                    console.error('API request failed with status:', res.status);
                }
            } catch (e) {
                console.error('Error fetching roster:', e);
            }
            if (!Array.isArray(roster) || roster.length === 0) {
                console.log('Using fallback dummy data');
                roster = Array.from({ length: 1000 }, (_, i) => ({
                    igUserId: 'p' + i,
                    username: 'Player ' + (i + 1),
                    avatarUrl: `https://i.pravatar.cc/128?img=${(i % 70) + 1}`,
                    baseHp: 100, baseArmor: 0, baseMass: 1.0,
                    boostHp: 0, boostArmor: 0, boostShield: 0,
                    eatRate: 15 + (i % 10)
                }));
            } else {
                console.log('Using imported roster with', roster.length, 'players');
            }

            roster = roster.slice(0, MAX_PLAYERS).map(p => ({ ...p, eatRate: p.eatRate ?? 20 }));

            console.log(`üéÆ Game starting with ${roster.length} players`);
            console.log('First few players:', roster.slice(0, 3).map(p => ({ username: p.username, igUserId: p.igUserId })));

            let PIZZA_HP_TOTAL;
            if (roster.length <= 6) {
                PIZZA_HP_TOTAL = 50;
            } else if (roster.length <= 12) {
                PIZZA_HP_TOTAL = 150;
            } else if (roster.length <= 20) {
                PIZZA_HP_TOTAL = 400;
            } else if (roster.length <= 50) {
                PIZZA_HP_TOTAL = 600;
            } else if (roster.length <= 200) {
                PIZZA_HP_TOTAL = 1500;
            } else {
                PIZZA_HP_TOTAL = roster.length * 8;
            }

            console.log(`Pizza HP: ${PIZZA_HP_TOTAL} f√ºr ${roster.length} Spieler`);

            // ====== RNG/Helpers ======
            const SEED = Date.now() % 1e9;
            let rng = (s => () => (s = Math.imul(48271, s) % 2147483647) / 2147483647)(SEED);
            function clamp(v, min, max) { return Math.max(min, Math.min(max, v)) }

            // ====== Canvas ======
            const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');

            // Stelle sicher, dass Canvas die richtige Instagram Reel Gr√∂√üe hat
            canvas.width = WIDTH;  // 1080
            canvas.height = HEIGHT; // 1920
            console.log(`üì∫ Canvas initialized: ${canvas.width}x${canvas.height}`);

            // Test das Canvas sofort mit einem sichtbaren Hintergrund
            const gradient = ctx.createRadialGradient(WIDTH / 2, HEIGHT / 2, 0, WIDTH / 2, HEIGHT / 2, HEIGHT / 2);
            gradient.addColorStop(0, '#101722');
            gradient.addColorStop(1, '#070a0f');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            console.log('üé® Canvas background gradient set');

            const uiTime = document.getElementById('t'), uiSub = document.getElementById('sub'), uiRank = document.getElementById('rank');            // ====== Load Images ======
            async function loadImage(url) {
                return new Promise(r => {
                    const i = new Image();

                    // F√ºr Instagram/Facebook CDN URLs den Proxy verwenden
                    let imageUrl = url;
                    if (url && (url.includes('cdninstagram.com') || url.includes('fbcdn.net'))) {
                        imageUrl = `http://localhost:4000/api/proxy-image?url=${encodeURIComponent(url)}`;
                    } else if (url && !url.startsWith('http://localhost')) {
                        // F√ºr andere externe URLs crossOrigin setzen
                        i.crossOrigin = "anonymous";
                    }

                    i.onload = () => r(i);
                    i.onerror = (e) => {
                        console.log(`Image load failed for ${url}:`, e.type);
                        r(null);
                    };
                    i.src = imageUrl;
                });
            }
            function initials(name) { return (name || '?').split(' ').map(s => s[0]).join('').slice(0, 2).toUpperCase(); }

            const pizzaImage = await loadImage('./pizza.png');
            console.log('Pizza image loaded:', pizzaImage ? 'success' : 'failed');

            const images = new Map();
            console.log('üñºÔ∏è  Loading images for', roster.length, 'players...');
            await Promise.all(roster.map(async p => {
                const img = p.avatarUrl ? await loadImage(p.avatarUrl) : null;
                images.set(p.igUserId, img);
                if (!img && p.avatarUrl) {
                    console.log(`‚ùå Failed to load image for ${p.username}: ${p.avatarUrl.substring(0, 50)}...`);
                } else if (img) {
                    console.log(`‚úÖ Loaded image for ${p.username}`);
                }
            }));
            console.log('üñºÔ∏è  Image loading completed');

            // ====== State ======
            let pizzaHP = PIZZA_HP_TOTAL;
            let players = roster.map((p, i) => {
                const x = AVA_R * 3 + rng() * (WIDTH - AVA_R * 6);
                const y = AVA_R * 3 + rng() * (HEIGHT - AVA_R * 6);
                const angle = rng() * Math.PI * 2;

                return {
                    id: p.igUserId, name: p.username, img: images.get(p.igUserId),
                    x, y,
                    vx: Math.cos(angle) * MAX_SPEED,
                    vy: Math.sin(angle) * MAX_SPEED,
                    score: 0,
                    mass: (p.baseMass || 1.0),
                    armor: (p.boostArmor || 0), shield: (p.boostShield || 0),
                    alive: true, rot: rng() * Math.PI * 2, eatRate: p.eatRate
                };
            });

            console.log(`üéØ Created ${players.length} players`);
            console.log('Sample player:', players[0]);
            console.log(`üçï Pizza HP: ${PIZZA_HP_TOTAL}`);
            console.log(`üì∫ Canvas size: ${WIDTH}x${HEIGHT}`);

            let time = 0, last = performance.now();
            let gameEnded = false, gameEndTime = 0;

            const recorder = setupRecorder(canvas);

            // WICHTIG: Initial render bevor Recording startet
            console.log('üé® Initial render starting...');

            // Hintergrund zeichnen
            const bgGradient = ctx.createRadialGradient(WIDTH / 2, HEIGHT / 2, 0, WIDTH / 2, HEIGHT / 2, HEIGHT / 2);
            bgGradient.addColorStop(0, '#101722');
            bgGradient.addColorStop(1, '#070a0f');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Pizza zeichnen als Test
            ctx.fillStyle = "#c78b2f";
            ctx.beginPath();
            ctx.arc(PIZZA_CENTER.x, PIZZA_CENTER.y, EAT_RADIUS, 0, Math.PI * 2);
            ctx.fill();

            console.log('üé® Initial render complete');

            // Recording nach Delay starten
            setTimeout(() => {
                console.log('üé¨ Starting recording...');
                recorder.start();
                requestAnimationFrame(loop);
            }, 1000);

            function loop(now) {
                const dt = clamp((now - last) / 1000, 0, 0.05); last = now; time += dt;

                uiTime.textContent = (Math.max(0, DURATION - time)).toFixed(1);
                updateRanking();

                const gameJustEnded = !gameEnded && ((time >= DURATION) || (pizzaHP <= 0.1));
                if (gameJustEnded) {
                    gameEnded = true;
                    gameEndTime = time;
                }

                if (gameEnded) {
                    const winnerDisplayDuration = time - gameEndTime;
                    if (winnerDisplayDuration >= WINNER_DISPLAY_TIME) {
                        render(true);
                        recorder.stop();
                        return;
                    }
                    render(true);
                } else {
                    step(dt);
                    render(false);
                }

                requestAnimationFrame(loop);
            }

            function step(dt) {
                for (const p of players) {
                    if (!p.alive) continue;

                    p.x += p.vx;
                    p.y += p.vy;

                    let collided = false;

                    if (p.x <= AVA_R) {
                        p.x = AVA_R;
                        p.vx = -p.vx;
                        collided = true;
                    }
                    if (p.x >= WIDTH - AVA_R) {
                        p.x = WIDTH - AVA_R;
                        p.vx = -p.vx;
                        collided = true;
                    }
                    if (p.y <= AVA_R) {
                        p.y = AVA_R;
                        p.vy = -p.vy;
                        collided = true;
                    }
                    if (p.y >= HEIGHT - AVA_R) {
                        p.y = HEIGHT - AVA_R;
                        p.vy = -p.vy;
                        collided = true;
                    }

                    if (collided) {
                        const speed = Math.hypot(p.vx, p.vy);
                        if (speed > 0) {
                            p.vx = (p.vx / speed) * MAX_SPEED;
                            p.vy = (p.vy / speed) * MAX_SPEED;
                        }
                    }
                }

                // Player collisions
                for (let i = 0; i < players.length; i++) {
                    const A = players[i];
                    if (!A.alive) continue;

                    for (let j = i + 1; j < players.length; j++) {
                        const B = players[j];
                        if (!B.alive) continue;

                        const dx = B.x - A.x;
                        const dy = B.y - A.y;
                        const dist = Math.hypot(dx, dy);
                        const minDist = AVA_R * 2;

                        if (dist > 0 && dist < minDist) {
                            const overlap = (minDist - dist) / 2;
                            const nx = dx / dist;
                            const ny = dy / dist;

                            A.x -= nx * overlap;
                            A.y -= ny * overlap;
                            B.x += nx * overlap;
                            B.y += ny * overlap;

                            const avn = A.vx * nx + A.vy * ny;
                            const bvn = B.vx * nx + B.vy * ny;

                            A.vx += (bvn - avn) * nx;
                            A.vy += (bvn - avn) * ny;
                            B.vx += (avn - bvn) * nx;
                            B.vy += (avn - bvn) * ny;

                            const aSpeed = Math.hypot(A.vx, A.vy);
                            const bSpeed = Math.hypot(B.vx, B.vy);
                            if (aSpeed > 0) {
                                A.vx = (A.vx / aSpeed) * MAX_SPEED;
                                A.vy = (A.vy / aSpeed) * MAX_SPEED;
                            }
                            if (bSpeed > 0) {
                                B.vx = (B.vx / bSpeed) * MAX_SPEED;
                                B.vy = (B.vy / bSpeed) * MAX_SPEED;
                            }
                        }
                    }
                }

                // Pizza collisions
                for (const p of players) {
                    if (!p.alive) continue;

                    const distToPizza = Math.hypot(p.x - PIZZA_CENTER.x, p.y - PIZZA_CENTER.y);

                    if (distToPizza > EAT_RADIUS - AVA_R && distToPizza <= EAT_RADIUS + AVA_R) {
                        const nx = (p.x - PIZZA_CENTER.x) / distToPizza;
                        const ny = (p.y - PIZZA_CENTER.y) / distToPizza;

                        p.x = PIZZA_CENTER.x + nx * (EAT_RADIUS + AVA_R);
                        p.y = PIZZA_CENTER.y + ny * (EAT_RADIUS + AVA_R);

                        const velDotNormal = p.vx * nx + p.vy * ny;
                        if (velDotNormal < 0) {
                            p.vx -= 2 * velDotNormal * nx;
                            p.vy -= 2 * velDotNormal * ny;
                        }

                        if (pizzaHP > 0) {
                            const eatAmount = p.eatRate * 0.1;
                            if (pizzaHP >= eatAmount) {
                                p.score += eatAmount;
                                pizzaHP -= eatAmount;
                            } else {
                                p.score += pizzaHP;
                                pizzaHP = 0;
                            }
                        }
                    }
                }
            }

            function render(final = false) {
                // Debug: Log render calls
                if (time % 5 < 0.1) { // Log every 5 seconds
                    console.log(`üé® Rendering at time ${time.toFixed(1)}s, players alive: ${players.filter(p => p.alive).length}, pizza HP: ${pizzaHP.toFixed(1)}`);
                }

                // Hintergrund zeichnen
                const gradient = ctx.createRadialGradient(WIDTH / 2, HEIGHT / 2, 0, WIDTH / 2, HEIGHT / 2, HEIGHT / 2);
                gradient.addColorStop(0, '#101722');
                gradient.addColorStop(1, '#070a0f');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, WIDTH, HEIGHT);

                drawPizza(ctx, PIZZA_CENTER.x, PIZZA_CENTER.y, EAT_RADIUS, pizzaHP / PIZZA_HP_TOTAL); for (const a of players) {
                    if (!a.alive) continue;
                    ctx.save();
                    ctx.translate(a.x, a.y);
                    a.rot = (a.rot || 0) + 0.01;
                    ctx.rotate(a.rot);

                    ctx.fillStyle = "#0e1a27";
                    ctx.beginPath();
                    ctx.arc(0, 0, AVA_R + 6, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(0, 0, AVA_R, 0, Math.PI * 2);
                    ctx.clip();
                    if (a.img) {
                        ctx.drawImage(a.img, -AVA_R, -AVA_R, AVA_R * 2, AVA_R * 2);
                    } else {
                        ctx.fillStyle = "#334155";
                        ctx.fillRect(-AVA_R, -AVA_R, AVA_R * 2, AVA_R * 2);
                        ctx.fillStyle = "#fff";
                        ctx.font = "bold 20px system-ui";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText(initials(a.name), 0, 2);
                    }
                    ctx.restore();

                    const s = Math.min(1, a.score / (PIZZA_HP_TOTAL * 0.25));
                    ctx.strokeStyle = s > 0.66 ? "#41ff9e" : s > 0.33 ? "#ffc148" : "#7aa2ff";
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, AVA_R + 10, -Math.PI / 2, -Math.PI / 2 + s * 2 * Math.PI);
                    ctx.stroke();
                    ctx.restore();
                }

                if (!final) {
                    const top10 = [...players].sort((a, b) => b.score - a.score).slice(0, 10);
                    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                    ctx.fillRect(WIDTH - 350, 170, 300, Math.min(top10.length * 32 + 40, 360));

                    ctx.fillStyle = "#fff";
                    ctx.font = "bold 32px system-ui";
                    ctx.textAlign = "left";
                    ctx.fillText("üèÜ TOP PIZZA EATER", WIDTH - 350, 150);

                    ctx.font = "32px system-ui";
                    top10.forEach((p, i) => {
                        const y = 80 + i * 32;
                        const isLeader = i === 0 && p.score > 0;

                        ctx.fillStyle = isLeader ? "#ffd700" : "#ffffff";
                        ctx.fillText(`${i + 1}.`, WIDTH - 350, y + 150);

                        const displayName = p.name.length > 12 ? p.name.substring(0, 12) + "..." : p.name;
                        ctx.fillText(displayName, WIDTH - 310, y + 150);

                        ctx.fillStyle = isLeader ? "#ffd700" : "#41ff9e";
                        ctx.textAlign = "right";
                        ctx.fillText(Math.round(p.score), WIDTH - 70, y + 150);
                        ctx.textAlign = "left";
                    });
                }

                if (final) {
                    const top = [...players].sort((a, b) => b.score - a.score).slice(0, 1)[0];
                    if (top) {
                        ctx.fillStyle = "rgba(0,0,0,.8)";
                        ctx.fillRect(0, HEIGHT * 0.3, WIDTH, 300);

                        // Gewinner-Profilbild 3x gr√∂√üer anzeigen
                        if (top.img) {
                            const winnerSize = AVA_R * 3; // 3x gr√∂√üer
                            const winnerX = WIDTH / 2;
                            const winnerY = HEIGHT * 0.3 + 50;

                            ctx.save();
                            ctx.translate(winnerX, winnerY);

                            // Schatten f√ºr Gewinner-Avatar
                            ctx.fillStyle = "#ffd700";
                            ctx.beginPath();
                            ctx.arc(0, 0, winnerSize + 8, 0, Math.PI * 2);
                            ctx.fill();

                            // Avatar clippen und zeichnen
                            ctx.beginPath();
                            ctx.arc(0, 0, winnerSize, 0, Math.PI * 2);
                            ctx.clip();
                            ctx.drawImage(top.img, -winnerSize, -winnerSize, winnerSize * 2, winnerSize * 2);
                            ctx.restore();
                        }

                        ctx.fillStyle = "#ffd700";
                        ctx.textAlign = "center";
                        ctx.font = "bold 64px system-ui";
                        ctx.fillText("üèÜ WINNER üèÜ", WIDTH / 2, HEIGHT * 0.3 + 180);

                        ctx.fillStyle = "#fff";
                        ctx.font = "bold 48px system-ui";
                        ctx.fillText(top.name, WIDTH / 2, HEIGHT * 0.3 + 240);

                        ctx.fillStyle = "#41ff9e";
                        ctx.font = "36px system-ui";
                        ctx.fillText(`${Math.round(top.score)} Pizza Eaten! üçï`, WIDTH / 2, HEIGHT * 0.3 + 290);

                        const top3 = [...players].sort((a, b) => b.score - a.score).slice(0, 3);
                        ctx.fillStyle = "#fff";
                        ctx.font = "24px system-ui";
                        top3.forEach((p, i) => {
                            const medals = ["ü•á", "ü•à", "ü•â"];
                            ctx.fillText(`${medals[i]} ${p.name}: ${Math.round(p.score)}`, WIDTH / 2, HEIGHT * 0.3 + 330 + i * 30);
                        });
                    }
                }
            }

            function updateRanking() {
                const sorted = [...players].sort((a, b) => b.score - a.score).slice(0, 10);
                uiRank.innerHTML = sorted.map((p, i) =>
                    `<li>${p.name}: ${Math.round(p.score)} Pizza</li>`
                ).join('');
            }

            function drawPizza(ctx, x, y, r, ratio) {
                ctx.save();

                if (pizzaImage) {
                    const size = r * 2;
                    ctx.translate(x, y);
                    ctx.drawImage(pizzaImage, -r, -r, size, size);

                    const eaten = 1 - clamp(ratio, 0, 1);
                    if (eaten > 0) {
                        ctx.fillStyle = "rgba(0,0,0,0.45)";
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.arc(0, 0, r, -Math.PI / 2, -Math.PI / 2 + eaten * 2 * Math.PI);
                        ctx.closePath();
                        ctx.fill();
                    }
                } else {
                    ctx.fillStyle = "#c78b2f";
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = "#f4d35e";
                    ctx.beginPath();
                    ctx.arc(x, y, r - 18, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = "#a11d1d";
                    const toppings = [
                        { x: 0.3, y: 0.2 }, { x: -0.4, y: 0.1 }, { x: 0.1, y: -0.3 }, { x: -0.2, y: -0.4 },
                        { x: 0.5, y: -0.1 }, { x: -0.1, y: 0.4 }, { x: 0.4, y: 0.3 }, { x: -0.3, y: -0.2 },
                        { x: 0.2, y: 0.5 }, { x: -0.5, y: 0.3 }, { x: 0.1, y: -0.5 }, { x: -0.4, y: -0.3 }
                    ];

                    toppings.forEach(topping => {
                        const tx = x + topping.x * (r - 35);
                        const ty = y + topping.y * (r - 35);
                        ctx.beginPath();
                        ctx.arc(tx, ty, 8, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    const eaten = 1 - clamp(ratio, 0, 1);
                    if (eaten > 0) {
                        ctx.fillStyle = "rgba(0,0,0,0.45)";
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.arc(x, y, r, -Math.PI / 2, -Math.PI / 2 + eaten * 2 * Math.PI);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                ctx.fillStyle = "#fff";
                ctx.font = "bold 22px system-ui";
                ctx.textAlign = "center";
                ctx.fillText(Math.round(ratio * 100) + "%", x, y + 8);
                ctx.restore();
            }

            function setupRecorder(canvas) {
                console.log('üé¨ Setting up recorder for canvas:', canvas.width, 'x', canvas.height);

                // Pr√ºfe ob Canvas Content hat
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const hasContent = imageData.data.some(pixel => pixel !== 0);
                console.log('üé® Canvas has content:', hasContent);

                const stream = canvas.captureStream(30);
                console.log('üé¨ Stream tracks:', stream.getTracks().length);

                // Verwende WebM mit VP9 f√ºr beste Qualit√§t und MP4-Kompatibilit√§t
                let mimeType = 'video/webm;codecs=vp9';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'video/webm;codecs=vp8';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'video/webm';
                    }
                }
                console.log('üé¨ Using mimeType:', mimeType);

                const rec = new MediaRecorder(stream, {
                    mimeType,
                    videoBitsPerSecond: 3000000  // H√∂here Qualit√§t
                });
                const chunks = [];

                rec.ondataavailable = e => {
                    if (e.data.size > 0) {
                        chunks.push(e.data);
                        console.log('üé¨ Data chunk received:', e.data.size, 'bytes');
                    }
                };

                rec.onstop = () => {
                    console.log('üé¨ Recording stopped. Total chunks:', chunks.length);
                    const totalSize = chunks.reduce((sum, chunk) => sum + chunk.size, 0);
                    console.log('üé¨ Total size:', totalSize, 'bytes');

                    if (totalSize === 0) {
                        alert('‚ùå Video ist leer! Canvas rendering problem detected.');
                        return;
                    }

                    const fileExtension = mimeType.includes('mp4') ? 'mp4' : 'webm';
                    const blob = new Blob(chunks, { type: mimeType });
                    console.log('üé¨ Final blob size:', blob.size, 'bytes');

                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `pizza-royale-${Date.now()}.${fileExtension}`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    console.log('üé¨ Video download triggered');

                    // Info f√ºr MP4 Konvertierung
                    if (fileExtension === 'webm') {
                        setTimeout(() => {
                            alert('üé¨ Video als WebM gespeichert!\n\nF√ºr MP4-Konvertierung verwende:\n./tools/to-mp4.sh pizza-royale-*.webm output.mp4');
                        }, 500);
                    }
                };

                rec.onstart = () => console.log('üé¨ Recording started successfully');
                rec.onerror = (e) => console.error('üé¨ Recording error:', e);

                return rec;
            }

        } // End of startGame function
    </script>
</body>

</html>